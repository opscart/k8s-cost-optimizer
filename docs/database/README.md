# Database Schema Documentation

## Overview

The k8s-cost-optimizer uses PostgreSQL to store recommendations, audit logs, and cached metrics.

**Database Name:** `costoptimizer`  
**Schema Version:** 1  
**Tables:** 5

---

## Tables

### 1. recommendations

Stores Kubernetes resource optimization recommendations.

**Purpose:** Track all recommendations generated by the cost analyzer, including what was recommended, potential savings, and whether it was applied.

**Schema:**
```sql
Column                       | Type         | Description
-----------------------------|--------------|------------------------------------------
id                          | UUID         | Primary key (auto-generated)
cluster_id                  | VARCHAR(255) | Kubernetes cluster identifier
namespace                   | VARCHAR(255) | Kubernetes namespace
deployment                  | VARCHAR(255) | Deployment name (optional)
pod                        | VARCHAR(255) | Pod name
container                  | VARCHAR(255) | Container name (optional)
type                       | VARCHAR(50)  | RIGHT_SIZE, SCALE_DOWN, NO_ACTION
current_cpu_millicores     | BIGINT       | Current CPU request (millicores)
current_memory_bytes       | BIGINT       | Current memory request (bytes)
recommended_cpu_millicores | BIGINT       | Recommended CPU (millicores)
recommended_memory_bytes   | BIGINT       | Recommended memory (bytes)
reason                     | TEXT         | Explanation for recommendation
savings_monthly_usd        | DECIMAL(10,2)| Estimated monthly savings
impact                     | VARCHAR(20)  | HIGH, MEDIUM, LOW
risk                       | VARCHAR(20)  | NONE, LOW, MEDIUM, HIGH
command                    | TEXT         | kubectl command to apply
created_at                 | TIMESTAMPTZ  | When recommendation was created
applied_at                 | TIMESTAMPTZ  | When recommendation was applied (nullable)
applied_by                 | VARCHAR(255) | Who applied it (nullable)
```

**Indexes:**
- `idx_recommendations_namespace` - Query by namespace
- `idx_recommendations_cluster` - Query by cluster
- `idx_recommendations_type` - Filter by recommendation type
- `idx_recommendations_created_at` - Sort by date

**Example Queries:**
```sql
-- Get all recommendations for a namespace
SELECT * FROM recommendations 
WHERE namespace = 'production' 
ORDER BY created_at DESC;

-- Get unapplied recommendations with high savings
SELECT * FROM recommendations 
WHERE applied_at IS NULL 
  AND savings_monthly_usd > 50
ORDER BY savings_monthly_usd DESC;

-- Total potential savings
SELECT SUM(savings_monthly_usd) as total_savings
FROM recommendations 
WHERE applied_at IS NULL;
```

---

### 2. audit_log

Tracks all actions taken on recommendations.

**Purpose:** Maintain a complete audit trail of who did what and when, for compliance and debugging.

**Schema:**
```sql
Column            | Type         | Description
------------------|--------------|------------------------------------------
id                | UUID         | Primary key (auto-generated)
recommendation_id | UUID         | Foreign key to recommendations (CASCADE)
action            | VARCHAR(50)  | APPLIED, ROLLED_BACK, VIEWED
status            | VARCHAR(50)  | SUCCESS, FAILED
error_message     | TEXT         | Error details if status=FAILED (nullable)
executed_by       | VARCHAR(255) | Username/email of executor (nullable)
executed_at       | TIMESTAMPTZ  | When action was executed
```

**Indexes:**
- `idx_audit_log_recommendation` - Query by recommendation
- `idx_audit_log_executed_at` - Sort by date

**Relationships:**
- Foreign key to `recommendations(id)` with CASCADE delete

**Example Queries:**
```sql
-- Get audit trail for a specific recommendation
SELECT * FROM audit_log 
WHERE recommendation_id = '36ea16fe-bb21-4d32-b463-f901e8739979'
ORDER BY executed_at DESC;

-- Get all failed actions
SELECT * FROM audit_log 
WHERE status = 'FAILED'
ORDER BY executed_at DESC;

-- Actions by user
SELECT action, status, COUNT(*) 
FROM audit_log 
WHERE executed_by = 'john@example.com'
GROUP BY action, status;
```

---

### 3. metrics_cache

Caches P95/P99 metrics from Prometheus to reduce query load.

**Purpose:** Store pre-computed percentile metrics to avoid expensive Prometheus queries. Cache expires after 24 hours.

**Schema:**
```sql
Column                    | Type         | Description
--------------------------|--------------|------------------------------------------
id                        | UUID         | Primary key (auto-generated)
cluster_id                | VARCHAR(255) | Cluster identifier
namespace                 | VARCHAR(255) | Namespace
pod                      | VARCHAR(255) | Pod name
p95_cpu_millicores       | BIGINT       | 95th percentile CPU usage
p99_cpu_millicores       | BIGINT       | 99th percentile CPU usage
max_cpu_millicores       | BIGINT       | Maximum CPU usage
avg_cpu_millicores       | BIGINT       | Average CPU usage
p95_memory_bytes         | BIGINT       | 95th percentile memory usage
p99_memory_bytes         | BIGINT       | 99th percentile memory usage
max_memory_bytes         | BIGINT       | Maximum memory usage
avg_memory_bytes         | BIGINT       | Average memory usage
requested_cpu_millicores | BIGINT       | Current CPU request
requested_memory_bytes   | BIGINT       | Current memory request
collected_at             | TIMESTAMPTZ  | When metrics were collected
duration_hours           | INTEGER      | Duration of metrics window (e.g., 168 = 7 days)
sample_count             | INTEGER      | Number of samples collected (nullable)
expires_at               | TIMESTAMPTZ  | Cache expiration time (24h from collected_at)
```

**Indexes:**
- `idx_metrics_cache_pod` - Query by cluster/namespace/pod
- `idx_metrics_cache_expires` - Cleanup expired entries
- `idx_metrics_cache_unique` - Unique constraint on (cluster_id, namespace, pod, collected_at)

**Cache Behavior:**
- TTL: 24 hours
- UPSERT: ON CONFLICT updates existing entry
- Cleanup: Manual or scheduled job to delete expired entries

**Example Queries:**
```sql
-- Get cached metrics for a pod
SELECT * FROM metrics_cache 
WHERE cluster_id = 'prod-cluster'
  AND namespace = 'default'
  AND pod = 'my-app-12345'
  AND expires_at > NOW()
ORDER BY collected_at DESC 
LIMIT 1;

-- Clean up expired cache entries
DELETE FROM metrics_cache 
WHERE expires_at < NOW();

-- Cache hit rate by namespace
SELECT namespace, 
       COUNT(*) as cached_pods,
       AVG(EXTRACT(EPOCH FROM (expires_at - collected_at))/3600) as avg_age_hours
FROM metrics_cache 
WHERE expires_at > NOW()
GROUP BY namespace;
```

---

### 4. clusters

Metadata about Kubernetes clusters being monitored.

**Purpose:** Track which clusters are being monitored, their configuration, and last seen timestamp.

**Schema:**
```sql
Column         | Type         | Description
---------------|--------------|------------------------------------------
id             | VARCHAR(255) | Primary key (cluster identifier)
name           | VARCHAR(255) | Human-readable cluster name
cloud_provider | VARCHAR(50)  | azure, aws, gcp, on-prem (nullable)
region         | VARCHAR(100) | Cloud region (nullable)
node_count     | INTEGER      | Number of nodes (nullable)
last_seen      | TIMESTAMPTZ  | Last time cluster was scanned (nullable)
created_at     | TIMESTAMPTZ  | When cluster was first registered
```

**Example Queries:**
```sql
-- List all clusters
SELECT id, name, cloud_provider, last_seen 
FROM clusters 
ORDER BY last_seen DESC;

-- Find stale clusters (not seen in 24h)
SELECT * FROM clusters 
WHERE last_seen < NOW() - INTERVAL '24 hours';

-- Clusters by cloud provider
SELECT cloud_provider, COUNT(*) 
FROM clusters 
GROUP BY cloud_provider;
```

---

### 5. schema_version

Tracks database schema version for migrations.

**Purpose:** Enable safe schema migrations and version tracking.

**Schema:**
```sql
Column     | Type        | Description
-----------|-------------|------------------------------------------
version    | INTEGER     | Primary key (schema version number)
applied_at | TIMESTAMPTZ | When this version was applied
```

**Current Version:** 1

**Example Queries:**
```sql
-- Check current schema version
SELECT version, applied_at FROM schema_version ORDER BY version DESC LIMIT 1;
```

---

## Relationships
```
recommendations (1) ──< (N) audit_log
  └─ ON DELETE CASCADE
```

When a recommendation is deleted, all associated audit log entries are automatically deleted.

---

## Indexes Summary

| Table           | Index Name                          | Columns                          | Purpose                    |
|-----------------|-------------------------------------|----------------------------------|----------------------------|
| recommendations | idx_recommendations_namespace       | namespace, created_at DESC       | Query by namespace         |
| recommendations | idx_recommendations_cluster         | cluster_id, created_at DESC      | Query by cluster           |
| recommendations | idx_recommendations_type            | type                             | Filter by type             |
| recommendations | idx_recommendations_created_at      | created_at DESC                  | Sort by date               |
| audit_log       | idx_audit_log_recommendation        | recommendation_id, executed_at   | Query by recommendation    |
| audit_log       | idx_audit_log_executed_at           | executed_at DESC                 | Sort by date               |
| metrics_cache   | idx_metrics_cache_pod               | cluster_id, namespace, pod       | Query by pod               |
| metrics_cache   | idx_metrics_cache_expires           | expires_at                       | Cleanup expired entries    |
| metrics_cache   | idx_metrics_cache_unique (UNIQUE)   | cluster_id, namespace, pod, time | Prevent duplicates         |

---

## Maintenance

### Cleanup Expired Cache Entries
```sql
-- Run daily
DELETE FROM metrics_cache WHERE expires_at < NOW();
```

### Backup
```bash
# Backup all data
docker exec k8s-cost-postgres pg_dump -U costuser costoptimizer > backup.sql

# Restore
docker exec -i k8s-cost-postgres psql -U costuser costoptimizer < backup.sql
```

### Statistics
```sql
-- Table sizes
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Row counts
SELECT 
    'recommendations' as table_name, COUNT(*) FROM recommendations
UNION ALL
SELECT 'audit_log', COUNT(*) FROM audit_log
UNION ALL
SELECT 'metrics_cache', COUNT(*) FROM metrics_cache
UNION ALL
SELECT 'clusters', COUNT(*) FROM clusters;
```

---

## Connection String Format
```bash
# Development
postgresql://costuser:devpassword@localhost:5432/costoptimizer?sslmode=disable

# Production (use environment variable)
export DATABASE_URL="postgresql://user:password@host:5432/database?sslmode=require"
```

---

## Future Enhancements

- Add `recommendations_history` table for time-series analysis
- Add `cost_trends` table for monthly cost tracking
- Add partitioning for `metrics_cache` by date
- Add materialized views for common aggregations
